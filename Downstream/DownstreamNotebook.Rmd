---
title: "Downstream Analysis Notebook"
subtitle: "Kallisto Bustools P8_15 trachea"
author: "Dídac Jiménez"
date: "26-03-2023"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
```

## Purpose

The purpose of this notebook is to analyze the counts matrix obtained from single cell RNA sequencing raw data. The process involves quality control, scaling, dimensional reduction extraction of differentially expressed genes and a comparison with the same procedure on _ground truth_ data. I used the Seurat package which provides all the tools needed for the analysis.

## Preparation and setup

### Libraries

Load libraries used in this notebook., indicate the preprocessing tool used, the species, and the path to the files.

```{r echo=FALSE, message=FALSE, warning=FALSE}
library(Seurat, quietly = TRUE)
library(dplyr, quietly = T)
library(tidyverse, quietly = T)
library(Matrix, quietly = TRUE)
library(DropletUtils, quietly = TRUE)
library(knitr)
```

### Set parameters

Indicate the preprocessing tool used, the species, and the path to the files.

```{r}
projectname<-"Prototype"
tool<-"KallistoBustools"#  "KallistoBustools", "UmiTools or "SalmonAlevin"
matrixpath<-"~/Work/Runs/newyear/output/counts_unfiltered/cells_x_genes.mtx"
featurespath<-"~/Work/Runs/newyear/output/counts_unfiltered/cells_x_genes.genes.txt" #Only for KB
cellspath<-"~/Work/Runs/newyear/output/counts_unfiltered/cells_x_genes.barcodes.txt" #Only for KB
MT_genespath<-"/home/student/Work/Code/scRNAseq-Preprocessing-benchmark/Refs/MTgenes.csv"
rRNA<- "/home/student/Work/Code/scRNAseq-Preprocessing-benchmark/Refs/rRNA.csv"
ensemblid2descriptionpath<-"~/Work/Code/scRNAseq-Preprocessing-benchmark/Refs/ensemblid2description.csv"
groundtruth_toptablepath<-"~/Work/Code/scRNAseq-Preprocessing-benchmark/Refs/anotated_table_P8_15.csv" # Make sure this file is obtained from the data of the same tissue
```

Other parameters to be used:

```{r}
min.cells.features <- c(5,5) # CreateSeuratObject. Include features detected in at least this many cells, and cells with at least this many features
nFeature_threshold <- c(500, 25000) # subset. Minimum and maximum number of features detected in a cell to be kept
nCount_threshold <- c(1000, 500000)  # subset. Minimum and maximum number of molecules detected in a cell to be kept
dispersion.cutoff <- c(0.1, Inf) # FindVariableFeatures: Threshold of log dispersion
mean.cutoff <- c(0.5, Inf) # FindVariableFeatures: Threshold of log mean expression
n.pcs <- 6 # Number of principal components used for clustering
resolution <- 0.1 # Resolution used in linear cluster
perplexity <- 15 # Perplexity for t-SNE 
# Cell types to label the clusters. Grab them from its respective TabulaMuris Rmd
cell_ontology_class <- c("mesenchymal cell","mesenchymal cell","blood cell","endothelial cell","epithelial cell","neuroendocrine cell","mesenchymal cell") 
```


### Load raw files into counts matrix

Outputs from each preprocessing tool are different. I will define and use different functions to generate a counts matrix.

```{r}
if (tool == "KallistoBustools"){
  counts<-ReadMtx(
    mtx = matrixpath,
    cells = cellspath,
    features = featurespath,
    cell.column = 1,
    feature.column = 1,
    cell.sep = "\t",
    feature.sep = "\t",
    skip.cell = 0,
    skip.feature = 0,
    mtx.transpose = TRUE,
    unique.features = TRUE,
    strip.suffix = FALSE
)
  # Ensembl version removal
  rownames(counts)<-sub('\\.[0-9]*$', '', rownames(counts))
}

if (tool == "SalmonAlevin"){
  txi <- tximport::tximport(matrixpath, type="alevin")
  counts<-txi$counts
  # Ensembl version removal
  rownames(counts)<- sub('\\.[0-9]*$', '', rownames(txi$counts))
}

if (tool == "UmiTools"){
  counts <- Read10X(sub("matrix.mtx.gz","",matrixpath), 
                  gene.column = 1)
}

```

### Tag mitochondrial genes

Mitochondrial genes must have a tag on their name so that we can use the proportion of mitochondrial transcripts as a quality control measure. This is better done before the construction of the `Seurat` object. For this, we will use a list of all mitochondrial genes (species dependent!) previously acquired. In the same manner we compute the proportion of ribosomal genes which we will use to regress it out of our dataset. Last, in the tabula muris study, the proportion of gene Rn45s is also computed to regress it out. We will compute the proportion of Rn18s which is a fragment of Rn45s to emulate their work.


```{r}
#List of the names of our genes
gene_names<-data.frame(ens=rownames(counts))

# Lists generated Using Biomart from Ensembl to  create a list of ENS genes corresponding to mitochondrial genes 
MT_genes<-data.frame(MT=read.csv(MT_genespath)) 
rRNA<-data.frame(rNA=read.csv(rRNA))

# Loop through all gene names and tag those found in the list
MT_count <-0
Rib_count <-0
Rn18s_count <- 0

for (i in 1:length(gene_names$ens)){
  if (gene_names$ens[i] %in% MT_genes$ensembl_gene_id){
    MT_count<-MT_count+1 # To check if it works
    gene_names$ens[i] <- paste(c("MT-",gene_names$ens[i]),sep="",collapse = "")
  }
}

for (i in 1:length(gene_names$ens)){
    if (gene_names$ens[i] == "ENSMUSG00000119584"){
      Rn18s_count<-Rn18s_count+1 # To check if it works
      gene_names$ens[i] <- paste(c("Rn18s-",gene_names$ens[i]),sep="",collapse = "")
    }
}

for (i in 1:length(gene_names$ens)){
    if (gene_names$ens[i] %in% rRNA$ensembl_gene_id){
      Rib_count<-Rib_count+1 # To check if it works
      gene_names$ens[i] <- paste(c("rib-",gene_names$ens[i]),sep="",collapse = "")
    }
}

# Change names in the raw data
row.names(counts)<-gene_names$ens # Change row names of counts matrix 
```

### Generate Seurat object

Finally we create the 'Seurat' object which we will use to proceed with the analysis.

```{r}
seurat.obj <- CreateSeuratObject(counts = counts, 
                                 project = "projectname", 
                                 min.cells = min.cells.features[1], 
                                 min.features = min.cells.features[2])
```

## Quality Control

### Data exploration

First we compute the percentage of mitochondrial transcripts for each cell, to use in later filtering. 

```{r}
# We use the label we added earlier and add the percentage as a column in the metadata of each cell
seurat.obj[["percent.mt"]]<-PercentageFeatureSet(seurat.obj,pattern = "MT")
seurat.obj[["percent.rib"]]<-PercentageFeatureSet(seurat.obj,pattern = "rib")
seurat.obj[["percent.Rn18s"]]<-PercentageFeatureSet(seurat.obj,pattern = "Rn18s")
```

We then plot the three metadata values: Mitochondrial percentage, number of molecules and number of features. A good dataset should have linear relationship between number of features and number of molecules, though a plateau is fine. As for the violin plot, we will use it to set the limits for our filtering.

```{r}
VlnPlot(seurat.obj, features = c("nCount_RNA", "nFeature_RNA","percent.mt", "percent.rib", "percent.Rn18s"), ncol = 5)
FeatureScatter(seurat.obj, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")+geom_smooth(method='lm')
```

### Filtering

We filter the cells by setting a limit on:
*Mitochondrial percentage: An upper limit, high values may indicate a broken nucleus, thus a compromised cell
*Number of molecules: An upper limit, very high values may indicate the droplet contained two cells
*Number of features: A lower limit, droplets with too few features may only contein environmental RNA

These filters depend on each dataset and should be changed on each execution.

```{r}
seurat.obj.filtered <- subset(x = seurat.obj, subset=nFeature_RNA > nFeature_threshold[1] & nFeature_RNA < nFeature_threshold[2] &
                                nCount_RNA > nCount_threshold[1] & nCount_threshold[2])
```

We make the violin plots again to check the filtering:

```{r}
VlnPlot(seurat.obj.filtered, features = c("nCount_RNA", "nFeature_RNA","percent.mt", "percent.rib", "percent.Rn18s"), ncol = 5)
FeatureScatter(seurat.obj.filtered, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")+geom_smooth(method='lm')
```

## Notmalization and scaling

### Normalization

Normalize the values so we can make comparisons across cells. Each value is divided by the total expression in its cell, multiplied by a scale factor and then log transformed.

$$
N_{ij}=log(1+M\frac{A_{ij}}{\sum_{j'}A_{ij'}}) \\
M=10⁴
$$

```{r}
seurat.obj.filtered<-NormalizeData(object=seurat.obj.filtered)
```

### Highly variable features

We do this to focus our analysis on the genes that differentiate our cells. We select the genes with high standarized log dispersion. The log dispersion $d$ of a gene $i$ with mean and variance standarized expresion $v_i,m_i$ is simply:

$$
d_i = log(v_i/m_i)
$$

Following Tabula muris approach, we keep those genes with $d_i>0.5$ and $log(m_i)>0.1$

```{r}
seurat.obj.filtered <- FindVariableFeatures(object = seurat.obj.filtered,  mean.cutoff = mean.cutoff,
  dispersion.cutoff = dispersion.cutoff)
```

### Scale data

We run `ScaleData()` to shift the expression of each gene, so that the mean expression across cells is 0 and scales the expression of each gene, so that the variance across cells is 1. This step gives equal weight in downstream analyses, so that highly-expressed genes do not dominate and is a required step prior to dimensional reduction techniques.

$$X{ij}=(N_{ij}-\mu_i)/\sigma_i$$

```{r}
gene_names <- rownames(seurat.obj.filtered)
seurat.obj.filtered <- ScaleData(seurat.obj.filtered, vars.to.regress = c("nCount_RNA",  "percent.rib", "percent.Rn18s"))
```

## Dimension reduction

### Principal Component Analysis

We run the analysis with `RunPCA()`. 

```{r message=FALSE}
seurat.obj.filtered <- RunPCA(seurat.obj.filtered, features =VariableFeatures(seurat.obj.filtered), ndims.print = 1)
seurat.obj.filtered <- ProjectDim(seurat.obj.filtered)
```

We make an elbow plot. We want to keep enough PC's to capture most of the variation

```{r}
ElbowPlot(seurat.obj.filtered)
```

From this plot we should choose the number of principal components to use in clustering.

### Clustering

Here we specify how many PCA's to use and the resolutions for the cluster.

```{r}
seurat.obj.filtered <- FindNeighbors(seurat.obj.filtered,dims = 1:n.pcs)
seurat.obj.filtered <- FindClusters(seurat.obj.filtered, resolution = resolution)
DimPlot(seurat.obj.filtered, group.by = paste("RNA_snn_res.",resolution, sep = ""), label = TRUE)
```

More useful, as it is the type of cluster graphic is the _t-distributed stochastic neighbor embedding_, which is a dimensionality reduction method that discriminates clusters really well. First, the probability proportional to similarity is calculated for each pair. For data point $x_{j}$ to data point $x_{i}$ this is the conditional probability, $p_{j|i}}$, that $x_{i}$ would pick $x_{j}$ as its neighbor if neighbors were picked in proportion to their probability density under a student t centered at $x_{i}$. Then a distribution in the lower space is computed iteratively (through gradient descent) to minimize the Kullback–Leibler divergence between it and the full dimensional distribution.

For our application, we will use Seurat's `RunTSNE`. It does not work directly on the genes as dimensions as t-SNE struggles with too many dimensions. It uses the principal components computed above, sins PC are good at separating signal from noise. We need to choose a parameter named perplexity that roughly sets how much impact closer points have over points further apart.

```{r}
seurat.obj.filtered <- RunTSNE(seurat.obj.filtered, dims.use = 1:n.pcs, seed.use = 10, perplexity = perplexity, dim.embed = 2)
TSNEPlot(seurat.obj.filtered)
```

We obtain the differentially expressed genes for each cluster with the function `FindAllMarkers`. This provides a table with the gene id, the cluster in which it is differentially expressed, both p-values (normal and adjusted, and only those under `return.thresh`) and the log fold change (more on it below).

```{r}
markers <- FindAllMarkers(object = seurat.obj.filtered, only.pos = TRUE, min.pct = 0.25, return.thresh = 0.01)
rownames(markers) <- c()
```

We read the description to add it to the previous table. And we display the 5 top markers for each gene, sorted by a metric provided by `FindAllMarkers` labeled as `log2FC`. The base 2 logarithm of the fold change tells us how much more expressed a gene is in a cluster of cells relative to the whole set of cells. The log2FC is:

$$log2FC=log_2(\frac{Average\ expression\ in\ set\ 1}{Average\ expression\ in\ set\ 2})$$

Where set 1 would be a given cluster and set 2 the whole set. However, the actual calculation in the function is:

```
data.1 <- apply(X = data.use[genes.use, cells.1, drop = F], MARGIN = 1, FUN = function(x) log(x = mean(x = expm1(x = x)) + pseudocount.use))
data.2 <- apply(X = data.use[genes.use, cells.2, drop = F], MARGIN = 1, FUN = function(x) log(x = mean(x = expm1(x = x)) + pseudocount.use))
total.diff <- (data.1 - data.2)
```

Which has 2 caveats:

* `pseudocount.use` is used because scRNA-Seq count marices are sparse and thus we add 1 to every gene for the calculation to avoid $log(0)$
* `expm1` is used instead of the base 2 logarithm. This function returns the natural logarithm minus one.

```{r}
ensemblid2description<-read.csv(ensemblid2descriptionpath)
anotated_table <- data.frame()
for(i in unique(markers$cluster)){
  markers %>% 
    dplyr::select(gene, p_val_adj, avg_log2FC, cluster) %>% 
    filter(cluster ==i) %>%
    top_n(5, avg_log2FC) %>%
    left_join(ensemblid2description, by = "gene") %>%
    dplyr::select(gene, p_val_adj, avg_log2FC, cluster, description) ->
    cluster
    anotated_table <- rbind(anotated_table, cluster)
}

knitr::kable(anotated_table)
```

Lastly we read the same table but obtained from the data preprocessed by Tabula Muris. We perform an inner join with the description to figure which clusters are equivalent. We don't do it on the keys because while the preprocessing pipelines of this project output the gene names as Ensembl stable IDs, the tabula muris project provides its files with HGNC symbols.

```{r}
anotated_table <- data.frame()
for(i in unique(markers$cluster)){
  markers %>% 
    dplyr::select(gene, p_val_adj, avg_log2FC, cluster) %>% 
    filter(cluster ==i) %>%
    top_n(10, avg_log2FC) %>%
    left_join(ensemblid2description, by = "gene") %>%
    dplyr::select(gene, p_val_adj, avg_log2FC, cluster, description) ->
    cluster
    anotated_table <- rbind(anotated_table, cluster)
}
groundtruth_toptable <- read.csv(groundtruth_toptablepath)
anotated_table %>% inner_join(groundtruth_toptable, by="description")  %>% select(gene.y, description, cluster.x, cluster.y) %>% knitr::kable(col.names = c("Gene", "Description", "Cluster of project", "Ground truth cluster"))
```

















